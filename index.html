<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tyler Lee — Flying Bionic Hand</title>
    <style>
      :root { --bg: #061021; --text: #e8fdf6; --accent: #00ffd0; --muted: #9fb7b0; }
      *{box-sizing:border-box}
      body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto;background:var(--bg);color:var(--text);overflow:hidden}
      nav{position:fixed;top:20px;right:40px;display:flex;gap:1.2rem;font-size:0.95rem;z-index:60}
      nav a{color:var(--muted);text-decoration:none;cursor:pointer;padding:6px 8px;border-radius:6px}
      nav a:hover{color:var(--accent);background:rgba(0,255,208,0.03)}
      .window{position:absolute;inset:0;display:none;justify-content:center;align-items:center;flex-direction:column;text-align:center;padding:0 10vw;background:rgba(6,16,33,0.6);transition:opacity .35s;z-index:50}
      .window.active{display:flex;opacity:1}
      h1,h2{margin:0 0 1rem}
      p{color:var(--muted);max-width:700px;line-height:1.7}
      #about{z-index:55}
      canvas#background{position:fixed;left:0;top:0;width:100vw;height:100vh;z-index:20;pointer-events:none;display:none}
      @media(max-width:700px){nav{right:12px}.window{padding:0 6vw}}
    </style>
  </head>
  <body>
    <canvas id="background"></canvas>
    <nav>
      <a data-target="about">About</a>
      <a data-target="left">Left Brain</a>
      <a data-target="right">Right Brain</a>
      <a data-target="contact">Contact</a>
    </nav>

    <div class="window active" id="about">
      <h1>Tyler Lee</h1>
      <p>Mechanical Engineering student developing a <strong>flying bionic hand</strong> — a new class of aerial bionic systems integrating dexterous manipulation and flight.</p>
    </div>

    <div class="window" id="left">
      <h2>Left Brain</h2>
      <p>I specialize in mechatronics, dynamics, and control systems — focusing on compact actuator design, cycloidal and planetary gear systems, and real-time motor control.</p>
    </div>

    <div class="window" id="right">
      <h2>Right Brain</h2>
      <p>Beyond engineering, I design expressive motion and biomimetic surfaces — every mechanism should feel alive, even in its precision.</p>
    </div>

    <div class="window" id="contact">
      <h2>Contact</h2>
      <p>YC reviewers and collaborators, reach out for prototype demos or discussions.</p>
      <p><a href="mailto:you@example.com" style="color:var(--accent)">you@example.com</a></p>
    </div>

    <script>
      window.addEventListener('load', ()=>{
        const navLinks=document.querySelectorAll('nav a');
        const windows=document.querySelectorAll('.window');
        const canvas=document.getElementById('background');
        function showWindow(id){windows.forEach(w=>w.classList.remove('active'));document.getElementById(id).classList.add('active');if(id==='about'){canvas.style.display='block'}else{canvas.style.display='none'}}
        navLinks.forEach(l=>l.addEventListener('click',()=>showWindow(l.dataset.target)));
        showWindow('about');

        // canvas setup
        const ctx=canvas.getContext('2d');
        let W=0,H=0,t=0;
        function resize(){const dpr=window.devicePixelRatio||1;W=canvas.width=Math.floor(window.innerWidth*dpr);H=canvas.height=Math.floor(window.innerHeight*dpr);canvas.style.width=window.innerWidth+'px';canvas.style.height=window.innerHeight+'px';ctx.setTransform(dpr,0,0,dpr,0,0)}
        window.addEventListener('resize',resize);resize();

        // gear geometry helpers
        const pitch = 8; // pixels per tooth (pitch)
        function pitchRadius(teeth){ return (pitch*teeth)/(2*Math.PI); }

        // gear drawing: rectangular teeth (spur-like)
        function drawSpurGear(cx,cy,R,teeth,angle,options={fill:true,stroke:true,bright:false,inner:false}){
          const toothDepth = Math.max(8, R*0.12);
          const rPitch = R; // assume R is pitch radius
          // body
          ctx.save();
          // fill body with radial gradient for shading
          const grad = ctx.createRadialGradient(cx,cy,Math.max(2,R*0.2),cx,cy,R*1.3);
          if(options.bright){ grad.addColorStop(0,'rgba(0,255,210,0.16)'); grad.addColorStop(0.6,'rgba(0,200,170,0.06)'); grad.addColorStop(1,'rgba(0,120,100,0.02)'); }
          else { grad.addColorStop(0,'rgba(0,255,210,0.08)'); grad.addColorStop(1,'rgba(0,120,100,0.02)'); }
          if(options.fill){ ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(cx,cy,rPitch,0,Math.PI*2); ctx.fill(); }
          if(options.stroke){ ctx.lineWidth=1.6; ctx.strokeStyle= options.bright ? 'rgba(0,255,210,0.98)' : 'rgba(0,255,210,0.7)'; ctx.beginPath(); ctx.arc(cx,cy,rPitch,0,Math.PI*2); ctx.stroke(); }

          // teeth drawn as rectangles positioned around outer circumference (or inner for ring)
          for(let i=0;i<teeth;i++){
            const a = angle + (i*(2*Math.PI/teeth));
            const cos=Math.cos(a), sin=Math.sin(a);
            // position at outer edge for spur; if inner (ring) draw inward
            const dir = options.inner ? -1 : 1;
            const baseR = rPitch + dir * (toothDepth*0.2);
            const tx = cx + cos*baseR;
            const ty = cy + sin*baseR;
            // rectangle size: width along circumference, depth radially
            const toothArc = (2*Math.PI/teeth) * rPitch;
            const w = Math.max(10, toothArc*0.6); // tooth width
            const h = toothDepth * 0.9; // tooth depth
            ctx.save();
            ctx.translate(tx,ty);
            ctx.rotate(a + (options.inner?Math.PI:0)); // inward teeth flipped
            // draw rectangle centered horizontally, extending radially outward/inward
            ctx.beginPath();
            ctx.fillStyle = options.bright ? 'rgba(0,255,210,0.98)' : 'rgba(0,255,210,0.75)';
            ctx.strokeStyle='rgba(0,255,210,0.9)';
            ctx.lineWidth=0.9;
            ctx.rect(-w/2, options.inner? -h : 0, w, h);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }

          // inner hole outline
          ctx.beginPath(); ctx.arc(cx,cy,Math.max(6,R*0.4),0,Math.PI*2); ctx.strokeStyle='rgba(0,255,210,0.06)'; ctx.stroke();
          ctx.restore();
        }

        // planetary system parameters
        const Ts = 40; // sun teeth
        const Tp = 26; // planet teeth
        const Tr = Ts + 2*Tp; // internal ring teeth
        const Rs = pitchRadius(Ts) * 1.5; // scaled up by 1.5x for size
        const Rp = pitchRadius(Tp) * 1.5;
        const Rr = pitchRadius(Tr) * 1.5;
        // recompute radii to ensure proper mesh: set Rp dist so planets sit between sun and ring
        const centerDist = Rs + Rp + 8; // small clearance

        // angular speeds (rad/s) - realistic slow
        const omegaSun = 0.7; // visual speed
        const omegaRing = -0.05; // slow opposite
        // compute carrier speed from gear relation: (omegaSun - omegaCarrier)/(omegaRing - omegaCarrier) = -Tr/Ts
        const ratio = Tr / Ts;
        const omegaCarrier = ( (ratio * omegaRing) + omegaSun ) / (1 + ratio);

        // compute planet spin such that (omegaPlanet + omegaCarrier)*Rp = omegaSun*Rs (meshing with sun)
        function planetSpin(omegaCarrier){ return (omegaSun * Rs) / Rp - omegaCarrier; }

        // place 3 planets evenly
        const planetAngles = [0, (2*Math.PI)/3, (4*Math.PI)/3];

        function drawConstruction(){ ctx.save(); ctx.globalAlpha=0.06; ctx.strokeStyle='rgba(0,255,210,0.06)'; ctx.lineWidth=1; // center lines
          ctx.beginPath(); ctx.arc(W*0.5,H*0.48,Math.min(W,H)*0.45,0,Math.PI*2); ctx.stroke(); ctx.restore(); }

        function loop(){
          t += 1/60; // time step
          ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

          drawConstruction();

          const cx = window.innerWidth*0.5; const cy = window.innerHeight*0.5;

          // draw ring (stationary but slightly rotating at omegaRing)
          const ringAngle = omegaRing * t;
          drawSpurGear(cx,cy,Rr,Tr,ringAngle,{fill:true,stroke:true,bright:true,inner:true});

          // draw sun (center)
          const sunAngle = omegaSun * t;
          drawSpurGear(cx,cy,Rs,Ts,sunAngle,{fill:true,stroke:true,bright:true,inner:false});

          // draw planets on carrier
          const carrierAngle = omegaCarrier * t;
          for(let i=0;i<3;i++){
            const ang = carrierAngle + planetAngles[i];
            const px = cx + Math.cos(ang) * centerDist;
            const py = cy + Math.sin(ang) * centerDist;
            const pSpin = planetSpin(omegaCarrier);
            const planetAngle = pSpin * t;
            drawSpurGear(px,py,Rp,Tp,planetAngle,{fill:true,stroke:true,bright:true,inner:false});
            // axle
            ctx.beginPath(); ctx.arc(px,py,Math.max(6,Rp*0.12),0,Math.PI*2); ctx.fillStyle='rgba(0,255,210,0.06)'; ctx.fill(); ctx.strokeStyle='rgba(0,255,210,0.12)'; ctx.stroke();
          }

          requestAnimationFrame(loop);
        }
        loop();
      });
    </script>
  </body>
</html>
